[plugins.oar]
enable = {{ .Values.plugins.oar.enable }}
jobs_only = {{ .Values.plugins.oar.jobs_only }}
oar_version = "{{ .Values.plugins.oar.version }}"
poll_interval = "1s"

[plugins.aggregation]
enable = {{ .Values.plugins.aggregation.enable }}
interval = "1m"
function = "Sum"
metrics = ["{{ .Values.plugins.aggregation.metrics }}"]

[plugins.csv]
enable = {{ .Values.plugins.csv.enable }}
output_path = "alumet-output.csv"
force_flush = true
append_unit_to_metric_name = true
use_unit_display_name = true
csv_delimiter = ";"
csv_late_delimiter = ","

[plugins.energy-estimation-tdp]
enable = {{ .Values.plugins.energyEstimationTdp.enable }}
tdp = {{ .Values.plugins.energyEstimationTdp.tdp }}
nb_vcpu = {{ .Values.plugins.energyEstimationTdp.nb_vcpu }}
nb_cpu = {{ .Values.plugins.energyEstimationTdp.nb_cpu }}
# Aligned with procfs.kernel's poll_interval
poll_interval = "5s"

[plugins.jetson]
enable = {{ .Values.plugins.jetson.enable }}
poll_interval = "1s"
flush_interval = "5s"

[plugins.k8s]
enable = {{ .Values.plugins.k8s.enable }}
poll_interval = "{{ .Values.plugins.k8s.poll_interval }}"
k8s_api_url = "https://kubernetes.default.svc:443"
k8s_node = "${NODE_NAME}"
token_retrieval = "file"
annotate_foreign_measurements = false

[plugins.nvml]
enable = {{ .Values.plugins.nvml.enable }}
poll_interval = "1s"
flush_interval = "5s"
skip_failed_devices = true
mode = "{{ .Values.plugins.nvml.mode }}"

[plugins.perf]
enable = {{ .Values.plugins.perf.enable }}
poll_interval = "1s"
flush_interval = "5s"
hardware_events = ["REF_CPU_CYCLES", "CACHE_MISSES", "BRANCH_MISSES"]
software_events = []
cache_events = ["LL_READ_MISS"]

[plugins.procfs]
enable = {{ .Values.plugins.procfs.enable }}

[plugins.procfs.kernel]
poll_interval = "5s"

[plugins.procfs.memory]
poll_interval = "5s"
metrics = [
    "MemTotal",
    "MemFree",
    "MemAvailable",
    "Cached",
    "SwapCached",
    "Active",
    "Inactive",
    "Mapped",
]

[plugins.procfs.network]
enabled = true
poll_interval = "5s"

[plugins.procfs.processes]
refresh_interval = "2s"
strategy = "watcher"

[[plugins.procfs.processes.groups]]
exe_regex = ""
poll_interval = "2s"
flush_interval = "4s"
memory_mode = "quick"

[plugins.procfs.processes.events]
poll_interval = "1s"
flush_interval = "4s"
memory_mode = "quick"

[plugins.rapl]
enable = {{ .Values.plugins.rapl.enable }}
poll_interval = "{{ .Values.plugins.rapl.poll_interval }}"
flush_interval = "{{ .Values.plugins.rapl.flush_interval }}"
no_perf_events = false

[plugins.energy-attribution]
enable = {{ .Values.plugins.energyAttribution.enable }}
{{ if and .Values.plugins.energyAttribution.enable .Values.plugins.rapl.enable }}
[plugins.energy-attribution.formulas.attributed_energy]
# the expression used to compute the final value
expr = "cpu_energy * cpu_usage / 100.0"
ref = "cpu_energy"
# The duration the measurement points are kept in memory before being dropped.
# This need to be coherent with the poll_interval of the metrics involved in this formula.
# Eg: If the metrics come from sources that poll every 1 second, it's recommanded to define the retention_time to at least 2 seconds.
# This way the plugin can make use of the precedent values of this metric to make interpolations.
{{ $poll := trimSuffix "s" .Values.plugins.rapl.poll_interval | int -}}
{{- $new_poll := add $poll 1 -}}
retention_time = "{{ $new_poll }}s"

# Timeseries related to the resources.
[plugins.energy-attribution.formulas.attributed_energy.per_resource]
# Defines the timeseries `cpu_energy` that is used in the formula, as the measurement points that have:
# - the metric `rapl_consumed_energy`,
# - and the resource kind `"local_machine"`
# - and the attribute `domain` equal to `package_total`
cpu_energy = { metric = "rapl_consumed_energy", resource_kind = "local_machine", domain = "package_total" }

# Timeseries related to the resource consumers.
[plugins.energy-attribution.formulas.attributed_energy.per_consumer]
# Defines the timeseries `cpu_usage` that is used in the formula, as the measurements points that have:
# - the metric `cpu_usage_percent`
# - the attribute `kind` equal to `total`
cpu_usage = { metric = "cpu_percent", kind = "total" }
{{- end }}
{{ if and .Values.plugins.energyAttribution.enable .Values.plugins.energyEstimationTdp.enable }}
[plugins.energy-attribution.formulas.attributed_estimate_energy]
# the expression used to compute the final value
expr = "cpu_energy * cpu_usage / 100.0"
ref = "cpu_energy"
# The duration the measurement points are kept in memory before being dropped.
# This need to be coherent with the poll_interval of the metrics involved in this formula.
# Eg: If the metrics come from sources that poll every 1 second, it's recommanded to define the retention_time to at least 2 seconds.
# This way the plugin can make use of the precedent values of this metric to make interpolations.
retention_time = "6s"

# Timeseries related to the resources.
[plugins.energy-attribution.formulas.attributed_estimate_energy.per_resource]
# Defines the timeseries `cpu_energy` that is used in the formula, as the measurement points that have:
# - the metric `estimated_energy`,
# - and the resource kind `"local_machine"`
cpu_energy = { metric = "estimated_energy", resource_kind = "local_machine" }

# Timeseries related to the resource consumers.
[plugins.energy-attribution.formulas.attributed_estimate_energy.per_consumer]
# Defines the timeseries `cpu_usage` that is used in the formula, as the measurements points that have:
# - the metric `cpu_usage_percent`
# - the attribute `kind` equal to `total`
cpu_usage = { metric = "cpu_percent", kind = "total" }
{{- end }}

[plugins.relay-client]
enable = {{ .Values.plugins.relay_client.enable }}
buffer_max_length = {{ .Values.plugins.relay_client.buffer_max_length }}
relay_server = '{{ .Values.plugins.relay_client.relay_server | default (printf "%s-alumet-relay-server" .Release.Name ) }}:{{ .Values.plugins.relay_client.port }}'
client_name = "${NODE_NAME}"
buffer_timeout = "{{ .Values.plugins.relay_client.buffer_timeout }}"

[plugins.relay-client.retry]
max_times = 8
initial_delay = "500ms"
max_delay = "4s"

[plugins.socket-control]
enable = {{ .Values.plugins.socket_control.enable }}
socket_path = "alumet-control.sock"

[plugins.opentelemetry]
enable = {{ .Values.plugins.opentelemetry.enable }}
push_interval_seconds = {{ .Values.plugins.opentelemetry.push_interval_seconds }}
collector_host = "{{ .Values.plugins.opentelemetry.collector_host }}"
prefix = ""
suffix = "_alumet"
use_unit_display_name = true
add_attributes_to_labels = true

[plugins.prometheus-exporter]
enable = {{ .Values.plugins.prometheusExporter.enable }}
port = {{ .Values.plugins.prometheusExporter.port }}
host = "0.0.0.0"
prefix = ""
suffix = "_alumet"
add_attributes_to_labels = true
